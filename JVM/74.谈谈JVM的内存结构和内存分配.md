#### 谈谈JVM的内存结构和内存分配

##### 参考答案

Java内存模型
Java虚拟机将其管辖的内存大致分三个逻辑部分：方法区(Method Area)、Java栈和Java堆。

方法区是静态分配的，编译器将变量绑定在某个存储位置上，而且这些绑定不会在运行时改变。

Java Stack是一个逻辑概念，特点是后进先出。一个栈的空间可能是连续的，也可能是不连续的。

Java堆分配(heap allocation)意味着以随意的顺序，在运行时进行存储空间分配和收回的内存管理模型。

java内存分配
基础数据类型直接在栈空间分配;
方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收;
引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量;

方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收;
局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收;
方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放;
字符串常量在 DATA 区域分配 ，this 在堆空间分配;

数组既在栈空间分配数组名称， 又在堆空间分配数组实际的大小！



##### 群友补充

###### From [BelieveFrank](https://github.com/BelieveFrank)

##### 内存结构

###### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

###### Java虚拟机栈

虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。
在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

###### 本方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

###### Java堆

对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。（栈上分配、标量替换会导致对象不分配在堆内存中）
Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。
如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

###### 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

##### 内存分配策略

###### 对象优先在Eden分配

**大多数情况下，对象在新生代Eden去中分配，（注：java堆中的新生代可分为Eden区和两个Survivor区），当Eden区中没有足够的空间进行分配时，虚拟机将发起一次Minor GC。**

> Minor GC 和 Full GC的区别
>
> - 新生代GC(Minor GC)：指的是发生在新生代中的垃圾收集动作，java对象的创建和回收非常频繁，所以Mnior GC非常频繁，一般回收速度也比较快。
> - 老年代GC(Major GC/Full FC):指发生在老年代中的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC慢10倍以上。

###### 大对象直接进入老年代

大对象是指，需要大量连续内存空间的java对象（写程序的时候应该避免“短命大对象”），经常出现大对象，容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来分给他们。
虚拟机提供-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接进入老年代，这么做为目的是为了避免在Eden以及两个Survivor区之间发生大量的内存复制（新生代的垃圾收集算法采用复制算法）。

###### 长期存活的对象将进入老年代

虚拟机给每个对象定义一个对象年龄（Age）的计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.其在Survivor中没经历一次Minior GC，Age就加1，当其Age增加到一定程度（默认15岁），就将其晋升到老年代。年龄阈值可以通过参数-XX:MxTenuringThreshold设置。

##### 动态对象的年龄判定

为了能更好的适应不同程序的内存状况，虚拟机不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，**如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。**

##### 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代中最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC。如果小于或者HandlePromotionFailure设置为不允许，那这时就改为一次Full GC。
分配担保解释：新生代使用复制算法完成垃圾收集，为了节约内存Survivor的设置的比较小，当Minor GC后如果还有大量对象存活，超过了一个Survivor的内存空间，这时就需要老年代进行分配担保，把Survivor中无法容纳的对象直接进入老年代。若虚拟机检查老年代中最大可用连续空间大于新生代所有对象总空间那么就能保证不需要发生Full GC，因为老年代的内存空间够用。反之，如果老年代中最大可用连续空间小于新生代所有对象总空间就需要在尝试Minor GC失败后进行Full Gc或者直接Full GC。