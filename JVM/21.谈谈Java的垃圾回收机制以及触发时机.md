#### 谈谈Java的垃圾回收机制以及触发时机

##### 参考答案

内存回收机制：就是释放掉在内存中已经没有用的对象，要判断怎样的对象是没用的，有两种方法：（1）采用标记数的方法，在给内存中的对象打上标记，对象被引用一次，计数加一，引用被释放，计数就减一，当这个计数为零时，这个对象就可以被回收，但是，此种方法，对于循环引用的对象是无法识别出来并加以回收的，（2）采用根搜索的方法，从一个根出发，搜索所有的可达对象，则剩下的对象就是可被回收的，垃圾回收是在虚拟机空闲的时候或者内存紧张的时候执行的，什么时候回收并不是由程序员控制的，可达与不可达的概念：分配对象使用new关键字，释放对象时，只需将对象的引用赋值为null，让程序不能够在访问到这个对象，则称该对象不可达。

在以下情况中垃圾回收机制会被触发：
（1）所有实例都没有活动线程访问 ；（2）没有其他任何实例访问的循环引用实例；（3）Java中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型。



##### 蛋友补充

###### From [safier](https://github.com/safier)

### 垃圾收集算法

#### 1. Mark-Sweep(标记-清除)算法

这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：

[![image](https://user-images.githubusercontent.com/20643294/57460977-bba90800-72a8-11e9-97d7-408255106e7d.png)](https://user-images.githubusercontent.com/20643294/57460977-bba90800-72a8-11e9-97d7-408255106e7d.png)

从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。

#### 2. Copying（复制）算法

为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：

[![image](https://user-images.githubusercontent.com/20643294/57461047-e1cea800-72a8-11e9-9dfb-2d0597cfef87.png)](https://user-images.githubusercontent.com/20643294/57461047-e1cea800-72a8-11e9-9dfb-2d0597cfef87.png)

这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。

#### 3. Mark-Compact（标记-整理）算法

了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：

[![image](https://user-images.githubusercontent.com/20643294/57461135-0b87cf00-72a9-11e9-92e0-2b67426165e2.png)](https://user-images.githubusercontent.com/20643294/57461135-0b87cf00-72a9-11e9-92e0-2b67426165e2.png)

#### 4. Generational Collection（分代收集）算法

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

　　目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

　　而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。

　　注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。