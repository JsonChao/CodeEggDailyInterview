#### Java 对象的内存分配过程是如何保证线程安全的

##### 参考答案

#### 内存分配

在Java中，创建一个对象的方法有很多种，如使用new、使用反射、使用Clone方法等，但是无论如何，对象在创建过程中，都需要进行内存分配。拿最常见的new关键字举例，当我们使用new创建对象后代码开始运行后，虚拟机执行到这条new指令的时候，会先检查要new的对象对应的类是否已被加载，如果没有被加载则先进行类加载。在类加载检查通过之后，就需要给对象进行内存分配了，分配的内存主要用来存放对象的实例变量。在进行内存分配时，需要根据对象中的实例变量情况等信息确定需要分配的空间大小，然后从Java堆中划分出这样一块区域（假设没有JIT优化）。根据JVM使用的垃圾回收器的类型，因其回收算法不同，会导致堆中内存分配情况不同。如标记-清楚算法回收后的内存中会有大量不连续的内存碎片，在给新的对象分配的时候，就需要通过"空闲列表"来确定一块空闲区域。无论那种方式，最终都需要确定出一块内存区域，用于给新建对象分配内存。我们知道，对象的内存分配过程中，主要是对象的引用指向这个内存区域，然后进行初始化操作。

#### 内存分配过程的线程安全性

1. 对分配内存空间的动作做同步处理，采用CAS机制，配合失败重试的方式保证更新操作的线程安全性。

   但是这种方案每次分配时都需要进行同步控制，这种是比较低效的。

2. 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配，当这部分区域用完之后，再分配新的"私有"内存。

   这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。**这里值得注意的是，我们说TLAB时线程独享的，但是只是在“分配”这个动作上是线程独占的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。**

   另外，TLAB仅作用于新生代的Eden Space，对象被创建的时候首先放到这个区域，但是新生代分配不了内存的大对象会直接进入老年代。因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。所以，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等。

   我们使用了TLAB之后，在TLAB上给对象分配内存时线程独享的了，这就没有冲突了，但是，TLAB这块内存自身从堆中划分出来的过程也可能存在内存安全问题啊。所以，在对于TLAB的分配过程，还是需要进行同步控制的。但是这种开销相比于每次为单个对象划分内存时候对进行同步控制的要低的多。虚拟机是否使用TLAB是可以选择的，可以通过设置-XX:+/-UseTLAB参数来指定。

#### 总结

为了保证Java对象的内存分配的安全性，同时提升效率，每个线程在Java堆中可以预先分配一小块内存，这部分内存称之为TLAB（Thread Local Allocation Buffer），这块内存的分配时线程独占的，读取、使用、回收是线程共享的。

可以通过设置-XX:+/-UseTLAB参数来指定是否开启TLAB分配。

参考资料：

《深入理解Java虚拟机》

https://www.cnblogs.com/straybirds/p/8529924.html 

https://www.zhihu.com/question/56538259