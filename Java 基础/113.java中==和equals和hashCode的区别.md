#### java中==和equals和hashCode的区别

1. 在java中"=="是用来比较变量值是否相等。如果是基本类型，直接比较值。如果是对象类型，比较的是两个对象的引用，也就是地址。对象是放在堆中的，栈中存放的是对象的引用。"==" 是对栈中的值进行比较的。
2. Object里有一个方法“equals”，这个方法是用来比较两个对象是否相等的。在Object类中有这样的代码：

```
public boolean equals(Object o) {
    return this == o;
}
```

1. 在Object里提供了hashcode这个方法。要说hashcode就得说java集合。java有的集合是不能重复的，所以需要用equeals判断集合中元素是否是同一个。但是如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。可以说hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。
2. "=="与"equals"关系：如果类没有重写equals，那么对于该类的对象来说“==”和“equals”没有区别。都是比较对象的内存地址。 但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。（特别注意String类）

##### 总结：

1. 如果两个对象相同，那么它们的hashCode值一定要相同；
2. 如果两个对象的hashCode相同，它们并不一定相同 ，上面说的对象相同指的是用eqauls方法比较。反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。 如果重写这两个方法最好遵循以上原则。所以比较两者还要看具体是如何重写的。